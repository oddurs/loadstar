//! Dotfile and configuration generator
//! Generates config files from wizard selections and writes them to disk.
//! Backs up existing files before overwriting.

use std::fs;
use std::io::Write;
use std::path::Path;
use std::sync::mpsc;

use crate::executor::InstallMessage;
use crate::system::SystemInfo;
use crate::wizard::{EditorChoice, MultiplexerChoice, PromptChoice, ShellChoice, WizardState};

/// Generate and write all config files based on wizard state
pub fn generate_configs(
    wizard: &WizardState,
    system: &SystemInfo,
    tx: &mpsc::Sender<InstallMessage>,
) {
    let _ = tx.send(InstallMessage::PhaseStart {
        phase: "Configuration Files".to_string(),
    });

    // .gitconfig
    let _ = tx.send(InstallMessage::Log(
        "[CONF] Generating .gitconfig".to_string(),
    ));
    let gitconfig = generate_gitconfig(wizard, system);
    write_config(
        &system.home_dir.join(".gitconfig"),
        &gitconfig,
        &system.home_dir,
        tx,
    );

    // starship.toml (if starship prompt selected)
    if wizard.shell_config.prompt == PromptChoice::Starship
        || wizard.selected_apps.contains("starship")
    {
        let _ = tx.send(InstallMessage::Log(
            "[CONF] Generating starship.toml".to_string(),
        ));
        let starship = generate_starship_config();
        let starship_dir = system.config_dir.join("starship.toml");
        ensure_parent_dir(&starship_dir);
        write_config(&starship_dir, &starship, &system.home_dir, tx);
    }

    // .zshrc (if zsh selected)
    if wizard.shell_config.shell == ShellChoice::Zsh {
        let _ = tx.send(InstallMessage::Log("[CONF] Generating .zshrc".to_string()));
        let zshrc = generate_zshrc(wizard, system);
        write_config(
            &system.home_dir.join(".zshrc"),
            &zshrc,
            &system.home_dir,
            tx,
        );
    }

    // tmux.conf (if tmux multiplexer selected)
    if wizard.shell_config.multiplexer == Some(MultiplexerChoice::Tmux)
        || wizard.selected_apps.contains("tmux")
    {
        let _ = tx.send(InstallMessage::Log(
            "[CONF] Generating tmux.conf".to_string(),
        ));
        let tmux = generate_tmux_config(system);
        write_config(
            &system.home_dir.join(".tmux.conf"),
            &tmux,
            &system.home_dir,
            tx,
        );
    }

    // .editorconfig
    let _ = tx.send(InstallMessage::Log(
        "[CONF] Generating .editorconfig".to_string(),
    ));
    let editorconfig = generate_editorconfig();
    write_config(
        &system.home_dir.join(".editorconfig"),
        &editorconfig,
        &system.home_dir,
        tx,
    );

    let _ = tx.send(InstallMessage::Log(
        "[CONF] All configuration files written".to_string(),
    ));
}

// â”€â”€â”€ Config generators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn generate_gitconfig(wizard: &WizardState, system: &SystemInfo) -> String {
    let editor_cmd = match wizard.editor {
        EditorChoice::Neovim => "nvim",
        EditorChoice::Helix => "hx",
        EditorChoice::VSCode => "code --wait",
        EditorChoice::Zed => "zed --wait",
        EditorChoice::None => "vim",
    };

    let is_work = wizard.identity.setup_type == crate::wizard::SetupType::Work;
    let has_delta = wizard.selected_apps.contains("delta");

    let mut config = format!(
        r#"# Generated by LOAD"*",8,1
# https://github.com/oddurs/loadstar

[user]
    name = {name}
    email = {email}

[core]
    editor = {editor}
    autocrlf = input
    excludesfile = ~/.config/git/ignore
"#,
        name = wizard.identity.name,
        email = wizard.identity.email,
        editor = editor_cmd,
    );

    if has_delta {
        config.push_str("    pager = delta\n");
    }

    config.push_str(
        r#"
[init]
    defaultBranch = main

[push]
    default = simple
    autoSetupRemote = true

[pull]
    rebase = true
    ff = only

[rebase]
    autoStash = true
    updateRefs = true

[merge]
    conflictstyle = zdiff3

[diff]
    algorithm = histogram
    colorMoved = default

[fetch]
    prune = true
    tags = true

[branch]
    autoSetupRebase = always
    sort = -committerdate

[status]
    showUntrackedFiles = all
"#,
    );

    // Delta config
    if has_delta {
        config.push_str(
            r#"
[interactive]
    diffFilter = delta --color-only

[delta]
    navigate = true
    light = false
    side-by-side = false
    line-numbers = true
    line-numbers-left-format = "{nm:>4}|"
    line-numbers-right-format = "{np:>4}|"
"#,
        );
    }

    // URL rewrites for SSH
    config.push_str(
        r#"
[url "git@github.com:"]
    insteadOf = "https://github.com/"
"#,
    );

    // Aliases
    config.push_str(
        r#"
[alias]
    s = status --short --branch
    st = status
    b = branch
    co = checkout
    cb = checkout -b
    sw = switch
    c = commit
    cm = commit --message
    ca = commit --all
    cam = commit --all --message
    amend = commit --amend
    a = add
    aa = add --all
    ap = add --patch
    d = diff
    ds = diff --staged
    l = log --oneline --graph --decorate
    lg = log --graph --pretty=format:'%C(red)%h%C(reset) -%C(yellow)%d%C(reset) %s %C(green)(%cr) %C(bold blue)<%an>%C(reset)' --abbrev-commit
    f = fetch --all
    p = push
    pf = push --force-with-lease
    pl = pull
    unstage = reset HEAD --
    undo = reset HEAD~1 --mixed
    cleanup = "!git branch --merged | grep -v '\\*\\|master\\|main' | xargs -n 1 git branch -d"
"#,
    );

    // GitHub user
    if !wizard.identity.github_username.is_empty() {
        config.push_str(&format!(
            "\n[github]\n    user = {}\n",
            wizard.identity.github_username
        ));
    }

    // Work-specific includes
    if is_work {
        config.push_str(
            r#"
[includeIf "gitdir:~/work/"]
    path = ~/.config/git/config.work
"#,
        );
    }

    // Ensure git ignore directory exists
    let git_config_dir = system.config_dir.join("git");
    let _ = fs::create_dir_all(&git_config_dir);

    // Write global gitignore
    let gitignore = r#".DS_Store
*.swp
*.swo
*~
.env
.env.local
.idea/
.vscode/
*.log
node_modules/
__pycache__/
.pytest_cache/
target/
"#;
    let _ = fs::write(git_config_dir.join("ignore"), gitignore);

    config
}

fn generate_starship_config() -> String {
    // Use a clean, good-defaults starship config
    r#"# Generated by LOAD"*",8,1
# Minimal, fast, beautiful prompt

format = """$all$character"""
right_format = """$cmd_duration$time"""
add_newline = true
scan_timeout = 10
command_timeout = 1000

[character]
success_symbol = "[â¯](bold green)"
error_symbol = "[â¯](bold red)"
vimcmd_symbol = "[â®](bold green)"

[directory]
truncation_length = 3
truncation_symbol = "â€¦/"
truncate_to_repo = true
style = "bold blue"

[git_branch]
format = "on [$symbol$branch(:$remote_branch)]($style) "
symbol = " "
style = "bold purple"

[git_status]
format = "([\\[$all_status$ahead_behind\\]]($style) )"
style = "bold red"

[cmd_duration]
min_time = 2_000
format = "took [$duration]($style)"
style = "yellow bold"

[time]
disabled = false
format = "at [$time]($style) "
style = "bold white"
time_format = "%H:%M"

[nodejs]
format = "via [$symbol($version )]($style)"
symbol = " "

[python]
format = "via [$symbol$pyenv_prefix($version )]($style)"
symbol = " "

[rust]
format = "via [$symbol($version )]($style)"
symbol = " "

[golang]
format = "via [$symbol($version )]($style)"
symbol = " "

[docker_context]
format = "via [$symbol$context]($style) "
symbol = " "
only_with_files = true

[kubernetes]
format = "on [$symbol$context( \\($namespace\\))]($style) "
symbol = "â˜¸ "
disabled = false

[package]
format = "is [$symbol$version]($style) "
symbol = "ðŸ“¦ "
"#
    .to_string()
}

fn generate_zshrc(wizard: &WizardState, system: &SystemInfo) -> String {
    let editor_cmd = match wizard.editor {
        EditorChoice::Neovim => "nvim",
        EditorChoice::Helix => "hx",
        EditorChoice::VSCode => "code",
        EditorChoice::Zed => "zed",
        EditorChoice::None => "vim",
    };

    let is_macos = system.os == crate::system::Os::MacOS;
    let has_eza = wizard.selected_apps.contains("eza");
    let has_bat = wizard.selected_apps.contains("bat");
    let has_fd = wizard.selected_apps.contains("fd");
    let has_btop = wizard.selected_apps.contains("btop");
    let has_dust = wizard.selected_apps.contains("dust");
    let has_zoxide = wizard.selected_apps.contains("zoxide");
    let has_fzf = wizard.selected_apps.contains("fzf");
    let has_mise = wizard.selected_apps.contains("mise");
    let has_direnv = wizard.selected_apps.contains("direnv");
    let has_starship = wizard.shell_config.prompt == PromptChoice::Starship
        || wizard.selected_apps.contains("starship");
    let has_atuin = wizard.selected_apps.contains("atuin");

    let mut zshrc = String::from(
        r#"# Generated by LOAD"*",8,1
# https://github.com/oddurs/loadstar

# â•â•â• Environment â•â•â•
export XDG_CONFIG_HOME="$HOME/.config"
export XDG_CACHE_HOME="$HOME/.cache"
export XDG_DATA_HOME="$HOME/.local/share"
export XDG_STATE_HOME="$HOME/.local/state"
"#,
    );

    zshrc.push_str(&format!(
        r#"
export EDITOR="{editor}"
export VISUAL="{editor}"
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
"#,
        editor = editor_cmd
    ));

    // History
    zshrc.push_str(
        r#"
# â•â•â• History â•â•â•
export HISTFILE="$XDG_STATE_HOME/zsh/history"
export HISTSIZE=1000000
export SAVEHIST=1000000
mkdir -p "$(dirname "$HISTFILE")"

setopt EXTENDED_HISTORY
setopt SHARE_HISTORY
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_FIND_NO_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_SAVE_NO_DUPS
setopt HIST_VERIFY
setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
setopt EXTENDED_GLOB
setopt AUTO_CD
setopt INTERACTIVE_COMMENTS
"#,
    );

    // PATH
    zshrc.push_str(
        r#"
# â•â•â• Path â•â•â•
path_prepend() { [[ -d "$1" ]] && [[ ":$PATH:" != *":$1:"* ]] && export PATH="$1:$PATH"; }

path_prepend "$HOME/.local/bin"
path_prepend "$HOME/.cargo/bin"
path_prepend "$HOME/.local/share/mise/shims"
"#,
    );

    if is_macos {
        zshrc.push_str(
            r#"path_prepend "/opt/homebrew/bin"
path_prepend "/opt/homebrew/sbin"
"#,
        );
    }

    zshrc.push_str("path_prepend \"$HOME/go/bin\"\n");

    // Tool aliases
    zshrc.push_str("\n# â•â•â• Aliases â•â•â•\n");

    if has_eza {
        zshrc.push_str(
            r#"if command -v eza >/dev/null 2>&1; then
    alias ls='eza --icons --git'
    alias ll='eza -l --icons --git --header'
    alias la='eza -la --icons --git --header'
    alias tree='eza --tree --icons'
fi
"#,
        );
    }

    if has_bat {
        zshrc.push_str(
            r#"if command -v bat >/dev/null 2>&1; then
    alias cat='bat --style=auto'
    export MANPAGER="sh -c 'col -bx | bat -l man -p'"
fi
"#,
        );
    }

    if has_fd {
        zshrc.push_str("command -v fd >/dev/null 2>&1 && alias find='fd'\n");
    }

    if has_btop {
        zshrc.push_str("command -v btop >/dev/null 2>&1 && alias top='btop'\n");
    }

    if has_dust {
        zshrc.push_str("command -v dust >/dev/null 2>&1 && alias du='dust'\n");
    }

    // Git aliases
    zshrc.push_str(
        r#"
alias g='git'
alias ga='git add'
alias gaa='git add --all'
alias gc='git commit'
alias gcm='git commit -m'
alias gco='git checkout'
alias gd='git diff'
alias gp='git push'
alias gs='git status'
alias glog='git log --oneline --graph --decorate'

# Navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias reload='exec zsh'
"#,
    );

    if is_macos {
        zshrc.push_str(
            r#"
# macOS
alias o='open'
alias flushdns='sudo dscacheutil -flushcache && sudo killall -HUP mDNSResponder'
"#,
        );
    }

    // Tool initialization
    zshrc.push_str("\n# â•â•â• Tool Initialization â•â•â•\n");

    if has_starship {
        zshrc.push_str("command -v starship >/dev/null 2>&1 && eval \"$(starship init zsh)\"\n");
    }

    if has_zoxide {
        zshrc.push_str(
            r#"if command -v zoxide >/dev/null 2>&1; then
    eval "$(zoxide init zsh)"
    alias cd='z'
fi
"#,
        );
    }

    if has_fzf {
        zshrc.push_str(
            r#"if command -v fzf >/dev/null 2>&1; then
    if command -v fd >/dev/null 2>&1; then
        export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'
        export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    fi
    export FZF_DEFAULT_OPTS="--height 40% --layout=reverse --border"
    source <(fzf --zsh) 2>/dev/null || true
fi
"#,
        );
    }

    if has_mise {
        zshrc.push_str("command -v mise >/dev/null 2>&1 && eval \"$(mise activate zsh)\"\n");
    }

    if has_direnv {
        zshrc.push_str("command -v direnv >/dev/null 2>&1 && eval \"$(direnv hook zsh)\"\n");
    }

    if has_atuin {
        zshrc.push_str("command -v atuin >/dev/null 2>&1 && eval \"$(atuin init zsh)\"\n");
    }

    // Completion
    zshrc.push_str(
        r#"
# â•â•â• Completion â•â•â•
autoload -Uz compinit
if [[ -n ~/.zcompdump(#qN.mh+24) ]]; then
    compinit -d "$XDG_CACHE_HOME/zsh/zcompdump-$ZSH_VERSION"
else
    compinit -C -d "$XDG_CACHE_HOME/zsh/zcompdump-$ZSH_VERSION"
fi

zstyle ':completion:*' menu select
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
"#,
    );

    // Custom functions
    zshrc.push_str(
        r#"
# â•â•â• Functions â•â•â•
mkcd() { mkdir -p "$1" && cd "$1"; }

# Local overrides
[[ -f "$HOME/.zshrc.local" ]] && source "$HOME/.zshrc.local"
"#,
    );

    zshrc
}

fn generate_tmux_config(system: &SystemInfo) -> String {
    let is_macos = system.os == crate::system::Os::MacOS;

    let mut config = String::from(
        r##"# Generated by LOAD"*",8,1
# https://github.com/oddurs/loadstar

# Prefix: Ctrl+Space
unbind C-b
set -g prefix C-Space
bind C-Space send-prefix

# General
set -g mouse on
set -g base-index 1
set -g pane-base-index 1
set -g renumber-windows on
set -g history-limit 50000
set -g display-time 4000
set -g status-interval 5
set -g focus-events on
set -g default-terminal "tmux-256color"
set -ga terminal-overrides ",xterm-256color*:Tc"
set -s escape-time 10
setw -g aggressive-resize on

# Reload
bind r source-file ~/.tmux.conf \; display-message "Config reloaded!"

# Navigation
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# Resize
bind -r H resize-pane -L 2
bind -r J resize-pane -D 2
bind -r K resize-pane -U 2
bind -r L resize-pane -R 2

# Split in current path
bind | split-window -h -c "#{pane_current_path}"
bind - split-window -v -c "#{pane_current_path}"
unbind '"'
unbind %

bind c new-window -c "#{pane_current_path}"

# Vi copy mode
setw -g mode-keys vi
bind-key -T copy-mode-vi v send-keys -X begin-selection
"##,
    );

    if is_macos {
        config
            .push_str("bind-key -T copy-mode-vi y send-keys -X copy-pipe-and-cancel \"pbcopy\"\n");
    } else {
        config.push_str("bind-key -T copy-mode-vi y send-keys -X copy-pipe-and-cancel \"xclip -selection clipboard\"\n");
    }

    // Minimal clean status bar
    config.push_str(
        r##"
# Status bar
set -g status on
set -g status-style "bg=#1e1e2e,fg=#cdd6f4"
set -g status-left "#[fg=#1e1e2e,bg=#89b4fa,bold] #S #[fg=#89b4fa,bg=#1e1e2e]"
set -g status-right "#[fg=#cdd6f4] %H:%M "
set -g status-left-length 50
set -g pane-border-style "fg=#313244"
set -g pane-active-border-style "fg=#89b4fa"
set -g message-style "fg=#1e1e2e,bg=#f9e2af"

# Window status
set -g window-status-format " #I #{b:pane_current_path} "
set -g window-status-current-format "#[fg=#1e1e2e,bg=#fab387] #I #{b:pane_current_path} "

# Local overrides
if-shell "[ -f ~/.tmux.local.conf ]" 'source ~/.tmux.local.conf'
"##,
    );

    config
}

fn generate_editorconfig() -> String {
    r#"# Generated by LOAD"*",8,1

root = true

[*]
indent_style = space
indent_size = 4
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.{js,jsx,ts,tsx,json,yml,yaml,css,scss,html}]
indent_size = 2

[*.md]
trim_trailing_whitespace = false

[Makefile]
indent_style = tab
"#
    .to_string()
}

// â”€â”€â”€ File writing utilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn write_config(path: &Path, content: &str, home_dir: &Path, tx: &mpsc::Sender<InstallMessage>) {
    // Backup existing file
    if path.exists() {
        let backup = path.with_extension(format!(
            "{}.load-backup",
            path.extension().and_then(|e| e.to_str()).unwrap_or("bak")
        ));

        match fs::copy(path, &backup) {
            Ok(_) => {
                let display_path = display_path(&backup, home_dir);
                let _ = tx.send(InstallMessage::Log(format!(
                    "  Backed up existing file to {}",
                    display_path
                )));
            }
            Err(e) => {
                let _ = tx.send(InstallMessage::Log(format!(
                    "  [WARN] Could not backup {}: {}",
                    path.display(),
                    e
                )));
            }
        }
    }

    // Write new config
    match fs::File::create(path).and_then(|mut f| f.write_all(content.as_bytes())) {
        Ok(()) => {
            let display = display_path(path, home_dir);
            let _ = tx.send(InstallMessage::Log(format!("  Wrote {}", display)));
        }
        Err(e) => {
            let _ = tx.send(InstallMessage::Log(format!(
                "  [ERROR] Failed to write {}: {}",
                path.display(),
                e
            )));
        }
    }
}

fn ensure_parent_dir(path: &Path) {
    if let Some(parent) = path.parent() {
        let _ = fs::create_dir_all(parent);
    }
}

/// Display a path relative to home directory (using ~)
fn display_path(path: &Path, home_dir: &Path) -> String {
    path.strip_prefix(home_dir)
        .map(|p| format!("~/{}", p.display()))
        .unwrap_or_else(|_| path.display().to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::wizard::{Identity, SetupType};

    fn test_wizard() -> WizardState {
        let mut state = WizardState::new();
        state.identity = Identity {
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
            github_username: "testuser".to_string(),
            setup_type: SetupType::Personal,
        };
        state
    }

    fn test_system() -> crate::system::SystemInfo {
        crate::system::SystemInfo::detect().unwrap()
    }

    #[test]
    fn gitconfig_contains_identity() {
        let wizard = test_wizard();
        let system = test_system();
        let config = generate_gitconfig(&wizard, &system);

        assert!(config.contains("name = Test User"));
        assert!(config.contains("email = test@example.com"));
        assert!(config.contains("user = testuser"));
        assert!(config.contains("defaultBranch = main"));
    }

    #[test]
    fn gitconfig_includes_delta_when_selected() {
        let mut wizard = test_wizard();
        wizard.selected_apps.insert("delta".to_string());
        let system = test_system();
        let config = generate_gitconfig(&wizard, &system);

        assert!(config.contains("pager = delta"));
        assert!(config.contains("[delta]"));
    }

    #[test]
    fn gitconfig_excludes_delta_when_not_selected() {
        let mut wizard = test_wizard();
        wizard.selected_apps.remove("delta");
        let system = test_system();
        let config = generate_gitconfig(&wizard, &system);

        assert!(!config.contains("pager = delta"));
    }

    #[test]
    fn gitconfig_work_mode_has_includeif() {
        let mut wizard = test_wizard();
        wizard.identity.setup_type = SetupType::Work;
        let system = test_system();
        let config = generate_gitconfig(&wizard, &system);

        assert!(config.contains("includeIf"));
        assert!(config.contains("~/work/"));
    }

    #[test]
    fn starship_config_is_valid_toml() {
        let config = generate_starship_config();
        assert!(config.contains("[character]"));
        assert!(config.contains("[directory]"));
        assert!(config.contains("[git_branch]"));
        assert!(config.contains("success_symbol"));
    }

    #[test]
    fn zshrc_contains_core_sections() {
        let wizard = test_wizard();
        let system = test_system();
        let zshrc = generate_zshrc(&wizard, &system);

        assert!(zshrc.contains("XDG_CONFIG_HOME"));
        assert!(zshrc.contains("HISTFILE"));
        assert!(zshrc.contains("setopt"));
        assert!(zshrc.contains("path_prepend"));
        assert!(zshrc.contains("alias"));
        assert!(zshrc.contains("compinit"));
    }

    #[test]
    fn zshrc_includes_tools_when_selected() {
        let mut wizard = test_wizard();
        wizard.selected_apps.insert("eza".to_string());
        wizard.selected_apps.insert("bat".to_string());
        wizard.selected_apps.insert("zoxide".to_string());
        wizard.selected_apps.insert("fzf".to_string());
        wizard.selected_apps.insert("starship".to_string());
        let system = test_system();
        let zshrc = generate_zshrc(&wizard, &system);

        assert!(zshrc.contains("eza"));
        assert!(zshrc.contains("bat"));
        assert!(zshrc.contains("zoxide"));
        assert!(zshrc.contains("fzf"));
        assert!(zshrc.contains("starship"));
    }

    #[test]
    fn tmux_config_has_key_sections() {
        let system = test_system();
        let config = generate_tmux_config(&system);

        assert!(config.contains("prefix C-Space"));
        assert!(config.contains("mouse on"));
        assert!(config.contains("mode-keys vi"));
        assert!(config.contains("status"));
    }

    #[test]
    fn editorconfig_is_valid() {
        let config = generate_editorconfig();
        assert!(config.contains("root = true"));
        assert!(config.contains("indent_style"));
        assert!(config.contains("[*.md]"));
        assert!(config.contains("[Makefile]"));
    }

    #[test]
    fn display_path_uses_tilde() {
        let home = std::path::PathBuf::from("/Users/test");
        let path = std::path::PathBuf::from("/Users/test/.gitconfig");
        assert_eq!(display_path(&path, &home), "~/.gitconfig");
    }

    #[test]
    fn display_path_absolute_when_not_in_home() {
        let home = std::path::PathBuf::from("/Users/test");
        let path = std::path::PathBuf::from("/etc/hosts");
        assert_eq!(display_path(&path, &home), "/etc/hosts");
    }
}
